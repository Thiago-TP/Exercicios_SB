\begin{enumerate}

    \item
    O programa abaixo realiza a cópia de um vetor de \textit{double words}, 
    convertendo-o de \textit{little endian} para \textit{big endian}.
    Complete o programa, indicando as instruções dos espaços em branco 
    (cada espaço deve ser preenchido com uma única instrução).
    \putNASM{little_endian.asm}

    \item
    Para cada código C abaixo, escreva o equivalente em Assembly IA-32.
    Diretivas em C \textbf{devem} ser substituídas por diretivas equivalentes em IA-32.
    Use os registradores para as variáveis locais (com exceção de estruturas de dados)
    e seção de Dados ou BSS para as variáveis estáticas ou globais.
    \textbf{Deve-se} utilizar os endereçamentos corretos 
    para cada tipo de estrutura de dados.
    Não se preocupe pelo fato do programa principal em C ser uma função.
    \begin{itemize}
        \item [(a)] \putC{vector_size_100.c}
        \item [(b)] \putC{matrix_matching.c}
        \item [(c)] \putC{vector_sum.c}
        \item [(d)] Não é permitido \asm{MUL} ou \asm{IMUL}.
                    \putC{100x100_matrix.c}
        \item [(e)] Assuma que o usuário vai digitar um número de 0 a 9.
                    \putC{weird_sum.c}
    \end{itemize}

    \item
    Escreva uma versão em C de cada uma das funções em Assembly IA-32
    (todas as funções em Assembly colocam o valor de retorno em EAX)
    seguindo as seguintes regras:
    \begin{enumerate}
        \item [(i)]
        todas as funções são compostas por uma \textbf{única instrução RETURN}
        sem criar variáveis locais,
        
        \item [(ii)]
        em nenhuma função em C pode ser utilizado deslocamento de bits 
        ($\ll$ ou $\gg$) e

        \item [(iii)]
        somente pode ser feita \textbf{uma única operação aritmética 
        e/ou uma única comparação} ($>$ ou $<$) nas funções em C.
    \end{enumerate}

    \begin{itemize}
        \item [(a)] \putNASM{foo1.asm}
        \item [(b)] \putNASM{foo2.asm}
        \item [(c)] \putNASM{foo3.asm}
        \item [(d)] \putNASM{foo4.asm}
    \end{itemize}

    \item   
    O código abaixo em C chama uma função em Assembly IA-32 que
    retorna o valor da multiplicação entre todos os elementos de um vetor.
    Escreva essa função em Assembly utilizando laços.
    \putC{f4_sum.c}

    \item
    O código abaixo em C, chama uma função em Assembly IA-32 que 
    retorna o produto interno entre uma matrix 1xN e outra Nx1.
    Ela recebe o ponteiro dos dois arrays unimensionais e o tamanho N deles.
    Assuma que o primeiro array é 1xN e o segundo é Nx1.
    Escreva essa função em Assembly (uilize laços).
    \putC{f4_mul.c}

    \item
    O programa em C abaixo solicita ao usuário os valoers de uma matriz 10x10
    e depois calcula a soma dos elementos da diagonal principal.
    Altere o programa para uma versão em que o programa principal continua em C
    mas a função \asm{soma()} esteja em Assembly IA-32.
    A função deve calcular a soma dos elementos da diagonal principal,
    recebendo o ponteiro da matriz, o tamanho dela (NxN),
    e a variável de retorno da soma como parâmetros mediante a pilha.
    Mostre o código Assembly da função 
    e indique se é necessário fazer alguma alteração no código principal em C. 
    \putC{soma.c}

    \item
    Considere a função \asm{f1} abaixo, escrita em C.
    Reescreva-a em Assembly IA-32, mantendo tipagem, 
    usando os enderaçentos adequados,
    enviando parâmetros locais pela pilha
    e retorno por \asm{eax}.
    Pode usar io.mac.
    \putC{f1.c}  

    \item
    Escreva o seguinte código em Assembly IA-32.
    Para isso é permitido o uso da bibiloteca io.mac
    para ler e escrever strings (PutStr, GetStr).
    O programa em Assembly deve mostrar 
    todas as mensagens indicadas no programa em C.
    Deve manter os ponteiros para arquivo em memória.
    Assuma que ambos arquivos, entrada e saída, já existem 
    (o arquivo de saída existe, mas está vazio).
    \putC{files.c}

    \item
    Faça um programa em Assembly IA-32 que:
    \begin{enumerate}
        \item [1.]
        Abre um arquivo em modo leitura (00), 
        com permissão para todos os usuários 
        possam ler, escrever e executar. 
        Nome do arquivo: `myfile1.txt' (na mesma pasta que o programa). 
        Lê $n$ valores de char do arquivo e os salva num array $x$. 
        Fecha o arquivo.

        \item [2.]
        Soma todos os elementos do array.

        \item [3.]
        Abre um arquivo em modo escrita (01), com permissão
        para somente o dono do arquivo ler, ecrever e executar. 
        Nome do arquivo: `myfile2.txt' (na mesma pasta que o programa). 
        Escreve no arquivo o valor da soma.
        Fecha o arquivo.
    \end{enumerate}

    \item
    Faça um programa em Assembly IA-32 que:
    \begin{enumerate}
        \item [1.]
        Abre um arquivo em modo leitura (00), 
        com permissão para todos os usuários 
        possam ler, escrever e executar. 
        Nome do arquivo: `myfile1.txt' (na mesma pasta que o programa). 
        Lê 100 valores de 16 bits do arquivo e os salva num array $x$. 
        Fecha o arquivo.

        \item [2.]
        Verifica por meio de um laço se os valores lidos são positivos,
        escrevendo 1 num array $y$ em caso afirmativo e 0 caso contrário.

        \item [3.]
        Abre um arquivo em modo escrita (01), com permissão
        para somente o dono do arquivo ler, ecrever e executar,
        enquanto outros possam apenas ler. 
        Nome do arquivo: `myfile2.txt' (na mesma pasta que o programa). 
        Escreve no arquivo o array $y$.
        Fecha o arquivo.
    \end{enumerate}

    \item
    Faça um programa em Assembly IA-32
    que multiplique duas matrizes 5x5 de inteiros.
    O programa deve primeiro fazer um laço 
    para preencher a primeira matriz a ser digitada pelo usuário.
    Depois deve fazer um laço 
    para preencher a segunda matriz digitada pelo usuário.
    Em seguida, deve multiplicar as duas matrizes
    e salvar o resultado em outra matriz.
    Utilize o endereçamento correto para matrizes.
    Os labals das matrizes devem ser declarados no SECTION BSS.
    Não é necessário imprimir mensagens para o usuário,
    nem mostrar o resultado final.

    \item
    Considere um número em ponto flutuante baseado no formato da IEEE.
    O número é formado por 6 bits. 
    Um bit para o sinal, 
    os próximos três bits para o expoente,
    e os últimos dois bits para a mantissa.
    Como visto em sala de aula, o formato IEEE possui números normalizados,
    não normalizados, duas representações de zero, infinito e NaN.
    Assumindo que arredondamentos são feitos utilizando
    o arredondamento ao inteiro mais infinito (\textit{ceil}),
    preencha a tabela abaixo nos campos 
    \textit{binário}, \textit{mantissa}, \textit{expoente} e \textit{valor}.
    No campo \textit{binário}, deve-se colocar o binário do número completo,
    enquanto que nos outros campos deve-se colocar números decimais.
    Pode utilizar notação exponencial ($2^{512}$) ou fracionária (2$\frac{1}{3}$).
    Quando pede-se o maior/menor número, não devem ser considerados os infinitos.

    \begin{table}[H]
        \begin{tabular}{|l|l|l|l|l|}
            \hline
            \textbf{Descrição}  & 
            \textbf{Binário}    & 
            \textbf{Mantissa}   &
            \textbf{Expoente}   &
            \textbf{Valor decimal} \\\hline
            Menos zero & 100000 & 0 & $-2.0$ & $-0.0$ \\\hline
            Número positivo mais próximo a zero & & & & \\\hline
            Infinito negativo & & & & \\\hline
            Maior número normalizado & & & & \\\hline
            Menor número não-normalizado & & & & \\\hline
            $5.0 - 0.75$ & & & & \\\hline
            $4.0 + 3.0$ & & & & \\
            \hline
        \end{tabular}
    \end{table}

    \item
    Considere um número em ponto flutuante baseado no formato da IEEE.
    O número é formado por 7 bits. 
    Um bit para o sinal, 
    os próximos quatro bits para o expoente,
    e os últimos dois bits para a mantissa.
    Como visto em sala de aula, o formato IEEE possui números normalizados,
    não normalizados, duas representações de zero, infinito e NaN.
    Assumindo que arredondamentos são feitos utilizando
    o arredondamento à fração par mais próxima (\textit{round}),
    preencha a tabela abaixo nos campos 
    \textit{binário}, \textit{mantissa}, \textit{expoente} e \textit{valor}.
    No campo \textit{binário}, deve-se colocar o binário do número completo,
    enquanto que nos outros campos deve-se colocar números decimais.
    Pode utilizar notação exponencial ($2^{512}$) ou fracionária (2$\frac{1}{3}$).
    Quando pede-se o maior/menor número, não devem ser considerados os infinitos.

    \begin{table}[H]
        \begin{tabular}{|l|l|l|l|l|}
            \hline
            \textbf{Descrição}  & 
            \textbf{Binário}    & 
            \textbf{Mantissa}   &
            \textbf{Expoente}   &
            \textbf{Valor decimal} \\\hline
            Menos zero & 1000000 & 0 & $-2.0$ & $-0.0$ \\\hline
            Número positivo mais próximo a zero & & & & \\\hline
            Maior número normalizado & & & & \\\hline
            Menor número não-normalizado & & & & \\\hline
            $4.0 + 3.0$ & & & & \\\hline
            $7.0 + 8.0$ & & & & \\
            \hline
        \end{tabular}
    \end{table}

    \item
    Considere um número em ponto flutuante de 9 bits 
    baseado na representação IEEE (segue as regras para números normalizados,
    não normalizados, representação de 0, infinito e NaN), sendo que 
    existe 4 bits para o expoente e 4 bits para mantissa.
    Preencha a tabela abaixo.
    Se for necessário, arredonde para a fração mais próxima.
    No campo valor pode usar números fracionários (por exemplo, $\frac{3}{4}$)
    ou inteiros por potência de 2 (por exemplo $3\times2^{-3}$).

    \begin{table}[H]
        \begin{tabular}{|l|l|l|l|l|}
            \hline
            \textbf{Número}  & 
            \textbf{Valor}    & 
            \textbf{Bit sinal}   &
            \textbf{Bits expoente}   &
            \textbf{Bits mantissa} \\\hline
            Zero & 0.0 & 0 & 0000 & 0000 \\\hline
            Negativo mais próximo a zero & & & & \\\hline
            Maior positivo & & & & \\\hline
            n/a & $-5.0$ & & & \\\hline
            n/a & $1\sfrac{9}{16}\times2^{-2}$ & & & \\\hline
            Menos um & $-1.0$ & & & \\\hline
            O resultado de $4-1\frac{9}{16}$ & & & & \\
            \hline
        \end{tabular}
    \end{table}

    \item
    Considere um número em ponto flutuante baseado no formato da IEEE.
    O número é formado por 10 bits. 
    Um bit para o sinal, 
    os próximos cinco bits para o expoente,
    e os últimos quatro bits para a mantissa.
    Como visto em sala de aula, o formato IEEE possui números normalizados,
    não normalizados, duas representações de zero, infinito e NaN.
    Assumindo que arrredondamentos são feitos utilizando
    o arredondamento para o par mais próximo,
    preencha a tabela abaixo nos campos 
    \textit{binário}, \textit{mantissa}, \textit{expoente} e \textit{valor}.
    No campo \textit{binário}, deve-se colocar o binário do número completo,
    enquanto que nos outros campos deve-se colocar números decimais.
    Pode utilizar notação exponencial ($25^{12}$) ou fracionária (2$\frac{1}{3}$).
    Quando pede-se o maior/menor número, não devem ser considerandos os infinitos.
    A base do expoente é 2.

    \begin{table}[H]
        \begin{tabular}{|l|l|l|l|l|}
            \hline
            \textbf{Descrição}  & 
            \textbf{Binário}    & 
            \textbf{Mantissa}   &
            \textbf{Expoente}   &
            \textbf{Valor decimal} \\\hline
            Número negativo mais próximo a zero & & & & \\\hline
            Maior número & & & & \\\hline
            Menor número não-normalizado & & & & \\\hline
            Menos um & & & & \\
            \hline
        \end{tabular}
    \end{table}

\end{enumerate}
